#!/usr/bin/env node
/**
 * Test View - Real-time test status from .test-map.json
 *
 * Usage:
 *   node test-view.js [module]           # Show module test status
 *   node test-view.js --summary          # Overall summary
 *   node test-view.js --untested         # List untested files
 *   node test-view.js --stale            # List stale tests
 *   node test-view.js --json             # JSON output
 *   node test-view.js --refresh          # Refresh .test-map.json first
 *
 * Data source: .test-map.json (auto-generated by test-mapper.js)
 */

import { promises as fs } from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { parseArgs } from './shared.js';

const SCRIPT_DIR = path.dirname(new URL(import.meta.url).pathname);

/**
 * Load .test-map.json
 */
async function loadTestMap(rootPath) {
  const mapPath = path.join(rootPath, '.test-map.json');
  try {
    const content = await fs.readFile(mapPath, 'utf-8');
    return JSON.parse(content);
  } catch (err) {
    return null;
  }
}

/**
 * Refresh .test-map.json by running test-mapper.js
 */
function refreshTestMap(rootPath) {
  const mapperPath = path.join(SCRIPT_DIR, 'test-mapper.js');
  try {
    execSync(`node "${mapperPath}" "${rootPath}"`, { stdio: 'inherit' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Format module status as markdown
 */
function formatModuleMarkdown(modulePath, moduleData) {
  const lines = [
    `# ${modulePath.split('/').pop()} æµ‹è¯•çŠ¶æ€`,
    '',
    `> æ•°æ®æ¥æº: .test-map.json | è·¯å¾„: ${modulePath}`,
    '',
    '## æ¦‚è§ˆ',
    '',
    '| æŒ‡æ ‡ | å€¼ |',
    '|------|-----|',
    `| æ€»æ–‡ä»¶æ•° | ${moduleData.total} |`,
    `| å·²è¦†ç›– | ${moduleData.covered} |`,
    `| è¿‡æœŸ | ${moduleData.stale} |`,
    `| æœªæµ‹è¯• | ${moduleData.untested} |`,
    `| è¦†ç›–çŽ‡ | ${moduleData.coverage} |`,
    ''
  ];

  const files = moduleData.files || {};
  const untested = Object.entries(files).filter(([, f]) => f.status === 'untested');
  const stale = Object.entries(files).filter(([, f]) => f.status === 'stale');
  const covered = Object.entries(files).filter(([, f]) => f.status === 'covered');

  if (untested.length > 0) {
    lines.push('## âš« æœªæµ‹è¯•', '');
    lines.push('| æ–‡ä»¶ | è·¯å¾„ |');
    lines.push('|------|------|');
    for (const [name, info] of untested.slice(0, 30)) {
      lines.push(`| \`${name}\` | ${info.path} |`);
    }
    if (untested.length > 30) {
      lines.push(`| ... | +${untested.length - 30} æ›´å¤š |`);
    }
    lines.push('');
  }

  if (stale.length > 0) {
    lines.push('## ðŸŸ¤ è¿‡æœŸ', '');
    lines.push('| æ–‡ä»¶ | æµ‹è¯• |');
    lines.push('|------|------|');
    for (const [name, info] of stale) {
      const tests = (info.tests || []).slice(0, 2).map(t => path.basename(t)).join(', ');
      lines.push(`| \`${name}\` | ${tests} |`);
    }
    lines.push('');
  }

  if (covered.length > 0) {
    lines.push('## âœ… å·²è¦†ç›–', '');
    lines.push('| æ–‡ä»¶ | æµ‹è¯• |');
    lines.push('|------|------|');
    for (const [name, info] of covered.slice(0, 20)) {
      const tests = (info.tests || []).slice(0, 2).map(t => path.basename(t)).join(', ');
      lines.push(`| \`${name}\` | ${tests} |`);
    }
    if (covered.length > 20) {
      lines.push(`| ... | +${covered.length - 20} æ›´å¤š |`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Format overall summary
 */
function formatSummary(testMap) {
  const summary = testMap.summary || {};
  const modules = testMap.modules || {};

  const lines = [
    '# æµ‹è¯•è¦†ç›–æ€»è§ˆ',
    '',
    `> ç”Ÿæˆæ—¶é—´: ${testMap.generated || 'unknown'}`,
    '',
    '## å…¨å±€ç»Ÿè®¡',
    '',
    '| æŒ‡æ ‡ | å€¼ |',
    '|------|-----|',
    `| æ€»æ–‡ä»¶ | ${summary.total || 0} |`,
    `| å·²è¦†ç›– | ${summary.covered || 0} |`,
    `| è¿‡æœŸ | ${summary.stale || 0} |`,
    `| æœªæµ‹è¯• | ${summary.untested || 0} |`,
    `| å½“å‰è¦†ç›–çŽ‡ | ${summary.coverage || '0%'} |`,
    `| ç›®æ ‡è¦†ç›–çŽ‡ | ${testMap.coverage?.target || 90}% |`,
    '',
    '## æ¨¡å—è¦†ç›–çŽ‡',
    '',
    '| æ¨¡å— | è¦†ç›–çŽ‡ | å·²è¦†ç›– | è¿‡æœŸ | æœªæµ‹è¯• |',
    '|------|--------|--------|------|--------|'
  ];

  // Sort by coverage ascending (worst first)
  const sorted = Object.entries(modules).sort((a, b) => {
    const covA = parseFloat(a[1].coverage) || 0;
    const covB = parseFloat(b[1].coverage) || 0;
    return covA - covB;
  });

  for (const [mod, data] of sorted) {
    const shortMod = mod.replace('js/agents/', '');
    lines.push(`| ${shortMod} | ${data.coverage} | ${data.covered} | ${data.stale} | ${data.untested} |`);
  }

  return lines.join('\n');
}

/**
 * List untested files
 */
function listUntested(testMap) {
  const modules = testMap.modules || {};
  const untested = [];

  for (const [mod, data] of Object.entries(modules)) {
    for (const [name, info] of Object.entries(data.files || {})) {
      if (info.status === 'untested') {
        untested.push({ module: mod, file: name, path: info.path });
      }
    }
  }

  return untested;
}

/**
 * List stale tests
 */
function listStale(testMap) {
  const modules = testMap.modules || {};
  const stale = [];

  for (const [mod, data] of Object.entries(modules)) {
    for (const [name, info] of Object.entries(data.files || {})) {
      if (info.status === 'stale') {
        stale.push({ module: mod, file: name, path: info.path, tests: info.tests });
      }
    }
  }

  return stale;
}

async function main() {
  const args = parseArgs(process.argv.slice(2), {
    summary: false,
    untested: false,
    stale: false,
    json: false,
    refresh: false
  });

  const targetPath = args._?.[0] || process.cwd();
  const rootPath = path.resolve(targetPath);

  // Refresh if requested
  if (args.refresh) {
    console.log('Refreshing .test-map.json...\n');
    refreshTestMap(rootPath);
  }

  // Load test map
  const testMap = await loadTestMap(rootPath);
  if (!testMap) {
    console.error('Error: .test-map.json not found. Run test-mapper.js first.');
    process.exit(1);
  }

  // Handle different modes
  if (args.untested) {
    const untested = listUntested(testMap);
    if (args.json) {
      console.log(JSON.stringify(untested, null, 2));
    } else {
      console.log(`=== æœªæµ‹è¯•æ–‡ä»¶ (${untested.length}) ===\n`);
      for (const item of untested.slice(0, 50)) {
        console.log(`  ${item.path}`);
      }
      if (untested.length > 50) {
        console.log(`  ... +${untested.length - 50} æ›´å¤š`);
      }
    }
    return;
  }

  if (args.stale) {
    const stale = listStale(testMap);
    if (args.json) {
      console.log(JSON.stringify(stale, null, 2));
    } else {
      console.log(`=== è¿‡æœŸæµ‹è¯• (${stale.length}) ===\n`);
      for (const item of stale) {
        const tests = (item.tests || []).slice(0, 2).map(t => path.basename(t)).join(', ');
        console.log(`  ${item.path}`);
        console.log(`    â†’ ${tests}`);
      }
    }
    return;
  }

  if (args.summary || !args._?.[0]) {
    const output = formatSummary(testMap);
    console.log(output);
    return;
  }

  // Module-specific view
  const modulePath = args._[0];
  const moduleData = testMap.modules?.[modulePath];

  if (!moduleData) {
    // Try partial match
    const matches = Object.keys(testMap.modules || {}).filter(m => m.includes(modulePath));
    if (matches.length === 1) {
      const output = formatModuleMarkdown(matches[0], testMap.modules[matches[0]]);
      console.log(output);
    } else if (matches.length > 1) {
      console.log('Multiple modules match:');
      for (const m of matches) {
        console.log(`  ${m}`);
      }
    } else {
      console.error(`Module not found: ${modulePath}`);
      process.exit(1);
    }
    return;
  }

  if (args.json) {
    console.log(JSON.stringify({ module: modulePath, ...moduleData }, null, 2));
  } else {
    const output = formatModuleMarkdown(modulePath, moduleData);
    console.log(output);
  }
}

main().catch(err => {
  console.error('Error:', err.message);
  process.exit(1);
});
