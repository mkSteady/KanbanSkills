<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¾èµ–æ ‘å¯è§†åŒ–</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #eee; }
    .header { padding: 16px 24px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; justify-content: space-between; align-items: center; }
    .header h1 { font-size: 20px; font-weight: 500; }
    .header a { color: #4da8da; text-decoration: none; }
    .controls { padding: 12px 24px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .controls label { font-size: 13px; color: #aaa; }
    .controls select, .controls input { padding: 6px 10px; border-radius: 4px; border: 1px solid #0f3460; background: #1a1a2e; color: #eee; font-size: 13px; }
    .controls input[type="range"] { width: 120px; }
    .legend { display: flex; gap: 16px; margin-left: auto; }
    .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
    #graph { width: 100%; height: calc(100vh - 120px); overflow: auto; }
    .node circle { stroke: #fff; stroke-width: 1.5px; cursor: pointer; }
    .node text { font-size: 10px; fill: #ccc; pointer-events: none; }
    .link { fill: none; stroke: #0f3460; stroke-width: 1px; }
    .tooltip { position: absolute; padding: 10px 14px; background: #16213e; border: 1px solid #0f3460; border-radius: 6px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; max-width: 320px; z-index: 100; }
    .tooltip .title { font-weight: 600; margin-bottom: 6px; color: #4da8da; }
    .tooltip .row { display: flex; justify-content: space-between; gap: 20px; margin: 3px 0; }
    .tooltip .label { color: #888; }
    .tooltip .value { color: #eee; }
    .tooltip .status { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 11px; }
    .status-covered { background: #1b4332; color: #52b788; }
    .status-stale { background: #5c4033; color: #e9c46a; }
    .status-untested { background: #3d1f1f; color: #e57373; }
    .loading { display: flex; justify-content: center; align-items: center; height: 60vh; color: #888; }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ“Š ä¾èµ–æ ‘å¯è§†åŒ–</h1>
    <a href="/">â† è¿”å› Dashboard</a>
  </div>
  <div class="controls">
    <label>è§†å›¾:
      <select id="viewMode">
        <option value="tree">æ ‘å½¢</option>
        <option value="force">åŠ›å¯¼å‘</option>
        <option value="radial">å¾„å‘</option>
      </select>
    </label>
    <label>å±‚çº§:
      <select id="moduleLevel">
        <option value="module">æ¨¡å—çº§</option>
        <option value="file">æ–‡ä»¶çº§</option>
        <option value="deps">ä¾èµ–å›¾</option>
      </select>
    </label>
    <label>æ˜¾ç¤º:
      <input type="checkbox" id="showImports" checked> ä¾èµ–
      <input type="checkbox" id="showImportedBy"> è¢«ä¾èµ–
    </label>
    <label>è¿‡æ»¤:
      <select id="depsFilter">
        <option value="core">æ ¸å¿ƒæ–‡ä»¶ (â‰¥5å¼•ç”¨)</option>
        <option value="top20">Top 20</option>
        <option value="top50">Top 50</option>
        <option value="all">å…¨éƒ¨ (æ…¢)</option>
      </select>
    </label>
    <label>æœç´¢: <input type="text" id="searchFile" placeholder="æ–‡ä»¶å..." style="width:120px"></label>
    <label>ç¼©æ”¾: <input type="range" id="zoom" min="0.1" max="2" step="0.1" value="1"></label>
    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:#52b788"></div> Covered</div>
      <div class="legend-item"><div class="legend-dot" style="background:#e9c46a"></div> Stale</div>
      <div class="legend-item"><div class="legend-dot" style="background:#e57373"></div> Untested</div>
      <div class="legend-item"><div class="legend-dot" style="background:#4da8da"></div> Module</div>
    </div>
  </div>
  <div id="graph"><div class="loading">åŠ è½½ä¸­...</div></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    const API_BASE = '/api';
    let depGraph = null;
    let testStatus = null;
    let staleStatus = null;

    async function loadData() {
      const params = new URLSearchParams(window.location.search);
      const project = params.get('project') || '';
      const query = project ? `?project=${encodeURIComponent(project)}` : '';

      const [depRes, testRes, staleRes] = await Promise.all([
        fetch(`${API_BASE}/dep-graph${query}`).then(r => r.json()).catch(() => null),
        fetch(`${API_BASE}/test-status${query}`).then(r => r.json()).catch(() => null),
        fetch(`${API_BASE}/stale-status${query}`).then(r => r.json()).catch(() => null)
      ]);

      depGraph = depRes;
      testStatus = testRes;
      staleStatus = staleRes;

      if (!depGraph || !depGraph.files) {
        document.getElementById('graph').innerHTML = '<div class="loading">æ— ä¾èµ–å›¾æ•°æ®ï¼Œè¯·å…ˆè¿è¡Œ pi deps build</div>';
        return;
      }

      renderGraph();
    }

    function getFileStatus(filePath) {
      if (!testStatus?.files) return 'unknown';
      const file = testStatus.files.find(f => f.path === filePath || filePath.endsWith(f.path));
      return file?.status || 'unknown';
    }

    function getNodeColor(node) {
      if (node.isModule) return '#4da8da';
      const status = getFileStatus(node.id);
      switch (status) {
        case 'covered': return '#52b788';
        case 'stale': return '#e9c46a';
        case 'untested': return '#e57373';
        default: return '#888';
      }
    }

    function buildHierarchy() {
      const files = depGraph.files;
      const moduleLevel = document.getElementById('moduleLevel').value;

      if (moduleLevel === 'module') {
        // Build hierarchical module tree (directories only, no files)
        const root = { id: 'root', name: depGraph.root, children: [], isModule: true };
        const nodeMap = { 'root': root };

        for (const [filePath, node] of Object.entries(files)) {
          const parts = filePath.split('/');
          let parent = root;
          let currentPath = '';

          // Only process directories (skip the file itself)
          for (let i = 0; i < parts.length - 1; i++) {
            currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];

            if (!nodeMap[currentPath]) {
              const newNode = {
                id: currentPath,
                name: parts[i],
                children: [],
                isModule: true,
                files: []
              };
              nodeMap[currentPath] = newNode;
              if (parent.children) parent.children.push(newNode);
            }
            parent = nodeMap[currentPath];
          }
          // Add file to its parent module
          if (parent.files) parent.files.push(filePath);
        }

        return root;
      }

      // Deps mode: return flat list of files with dependency info
      if (moduleLevel === 'deps') {
        const nodes = [];
        const nodeMap = {};
        for (const [filePath, node] of Object.entries(files)) {
          const fileNode = {
            id: filePath,
            name: filePath.split('/').pop(),
            imports: node.imports || [],
            importedBy: node.importedBy || [],
            isModule: false
          };
          nodes.push(fileNode);
          nodeMap[filePath] = fileNode;
        }
        return { nodes, nodeMap, isDepsMode: true };
      }

      // File-level: build tree from file paths
      const root = { id: 'root', name: depGraph.root, children: [], isModule: true };
      const nodeMap = { 'root': root };

      for (const [filePath, node] of Object.entries(files)) {
        const parts = filePath.split('/');
        let parent = root;
        let currentPath = '';

        for (let i = 0; i < parts.length; i++) {
          currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
          const isFile = i === parts.length - 1;

          if (!nodeMap[currentPath]) {
            const newNode = {
              id: currentPath,
              name: parts[i],
              children: isFile ? undefined : [],
              isModule: !isFile,
              imports: node.imports,
              importedBy: node.importedBy,
              exports: node.exports
            };
            nodeMap[currentPath] = newNode;
            if (parent.children) parent.children.push(newNode);
          }
          parent = nodeMap[currentPath];
        }
      }

      return root;
    }

    function renderGraph() {
      const container = document.getElementById('graph');
      container.innerHTML = '';

      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      const viewMode = document.getElementById('viewMode').value;
      const zoomLevel = parseFloat(document.getElementById('zoom').value);
      const showImports = document.getElementById('showImports')?.checked ?? true;
      const showImportedBy = document.getElementById('showImportedBy')?.checked ?? false;
      const depsFilter = document.getElementById('depsFilter')?.value ?? 'core';
      const searchFile = document.getElementById('searchFile')?.value?.toLowerCase() ?? '';

      const hierarchy = buildHierarchy();

      // Handle deps mode separately (force-directed graph of file dependencies)
      if (hierarchy.isDepsMode) {
        renderDepsGraph(container, hierarchy, containerWidth, containerHeight, zoomLevel, showImports, showImportedBy, depsFilter, searchFile);
        return;
      }

      const root = d3.hierarchy(hierarchy);

      // Calculate dynamic dimensions based on tree size
      const nodeCount = root.descendants().length;
      const nodeSpacing = 20;
      const width = Math.max(containerWidth, root.height * 200 + 200);
      const height = Math.max(containerHeight, nodeCount * nodeSpacing + 100);

      const svg = d3.select('#graph')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      const g = svg.append('g')
        .attr('transform', `translate(${containerWidth/2}, ${containerHeight/2}) scale(${zoomLevel})`);

      if (viewMode === 'tree') {
        const treeLayout = d3.tree()
          .size([height - 100, width - 200])
          .separation((a, b) => a.parent === b.parent ? 1 : 1.5);
        treeLayout(root);

        g.attr('transform', `translate(80, 20) scale(${zoomLevel})`);

        // Links
        g.selectAll('.link')
          .data(root.links())
          .enter()
          .append('path')
          .attr('class', 'link')
          .attr('d', d3.linkHorizontal().x(d => d.y).y(d => d.x));

        // Nodes
        const nodes = g.selectAll('.node')
          .data(root.descendants())
          .enter()
          .append('g')
          .attr('class', 'node')
          .attr('transform', d => `translate(${d.y}, ${d.x})`);

        nodes.append('circle')
          .attr('r', d => d.data.isModule ? 8 : 5)
          .attr('fill', d => getNodeColor(d.data))
          .on('mouseover', showTooltip)
          .on('mouseout', hideTooltip);

        nodes.append('text')
          .attr('dx', 12)
          .attr('dy', 4)
          .text(d => d.data.name.replace('.js', ''));

      } else if (viewMode === 'radial') {
        const radius = Math.min(containerWidth, containerHeight) / 2 - 100;
        g.attr('transform', `translate(${containerWidth/2}, ${containerHeight/2}) scale(${zoomLevel})`);
        const treeLayout = d3.tree()
          .size([2 * Math.PI, radius])
          .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);

        treeLayout(root);

        g.selectAll('.link')
          .data(root.links())
          .enter()
          .append('path')
          .attr('class', 'link')
          .attr('d', d3.linkRadial().angle(d => d.x).radius(d => d.y));

        const nodes = g.selectAll('.node')
          .data(root.descendants())
          .enter()
          .append('g')
          .attr('class', 'node')
          .attr('transform', d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y}, 0)`);

        nodes.append('circle')
          .attr('r', d => d.data.isModule ? 6 : 4)
          .attr('fill', d => getNodeColor(d.data))
          .on('mouseover', showTooltip)
          .on('mouseout', hideTooltip);

        nodes.append('text')
          .attr('dx', d => d.x < Math.PI ? 8 : -8)
          .attr('dy', 3)
          .attr('text-anchor', d => d.x < Math.PI ? 'start' : 'end')
          .attr('transform', d => d.x >= Math.PI ? 'rotate(180)' : null)
          .text(d => d.children ? '' : d.data.name.replace('.js', ''));

      } else { // force
        g.attr('transform', `translate(${containerWidth/2}, ${containerHeight/2}) scale(${zoomLevel})`);
        const nodes = root.descendants();
        const links = root.links();

        const simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id).distance(50))
          .force('charge', d3.forceManyBody().strength(-100))
          .force('center', d3.forceCenter(0, 0));

        const link = g.selectAll('.link')
          .data(links)
          .enter()
          .append('line')
          .attr('class', 'link');

        const node = g.selectAll('.node')
          .data(nodes)
          .enter()
          .append('g')
          .attr('class', 'node')
          .call(d3.drag()
            .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
            .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
            .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }));

        node.append('circle')
          .attr('r', d => d.data.isModule ? 8 : 5)
          .attr('fill', d => getNodeColor(d.data))
          .on('mouseover', showTooltip)
          .on('mouseout', hideTooltip);

        node.append('text')
          .attr('dx', 10)
          .attr('dy', 4)
          .text(d => d.data.name.replace('.js', ''));

        simulation.on('tick', () => {
          link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
          node.attr('transform', d => `translate(${d.x}, ${d.y})`);
        });
      }

      // Zoom behavior
      svg.call(d3.zoom().scaleExtent([0.1, 4]).on('zoom', (e) => g.attr('transform', e.transform)));
    }

    function renderDepsGraph(container, data, width, height, zoomLevel, showImports, showImportedBy, depsFilter, searchFile) {
      let { nodes, nodeMap } = data;

      // Filter nodes based on settings
      if (searchFile) {
        // Show only the searched file and its direct dependencies
        const matchedNodes = nodes.filter(n => n.id.toLowerCase().includes(searchFile));
        if (matchedNodes.length > 0) {
          const relatedIds = new Set();
          for (const n of matchedNodes) {
            relatedIds.add(n.id);
            n.imports.forEach(i => relatedIds.add(i));
            n.importedBy.forEach(i => relatedIds.add(i));
          }
          nodes = nodes.filter(n => relatedIds.has(n.id));
        }
      } else if (depsFilter === 'core') {
        nodes = nodes.filter(n => n.importedBy.length >= 5);
      } else if (depsFilter === 'top20') {
        nodes = [...nodes].sort((a, b) => b.importedBy.length - a.importedBy.length).slice(0, 20);
      } else if (depsFilter === 'top50') {
        nodes = [...nodes].sort((a, b) => b.importedBy.length - a.importedBy.length).slice(0, 50);
      }
      // 'all' keeps all nodes

      // Rebuild nodeMap for filtered nodes
      const filteredNodeMap = {};
      for (const n of nodes) {
        filteredNodeMap[n.id] = n;
      }

      // Build links from dependency data
      const links = [];
      for (const node of nodes) {
        if (showImports) {
          for (const imp of node.imports) {
            if (filteredNodeMap[imp]) {
              links.push({ source: node.id, target: imp, type: 'import' });
            }
          }
        }
        if (showImportedBy) {
          for (const by of node.importedBy) {
            if (filteredNodeMap[by]) {
              links.push({ source: by, target: node.id, type: 'importedBy' });
            }
          }
        }
      }

      const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      // Add defs for markers and filters
      const defs = svg.append('defs');

      // Arrow marker
      defs.append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '-0 -5 10 10')
        .attr('refX', 15)
        .attr('refY', 0)
        .attr('orient', 'auto')
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .append('path')
        .attr('d', 'M 0,-5 L 10,0 L 0,5')
        .attr('fill', '#0f3460');

      // Glow filter for highlighted nodes
      const glow = defs.append('filter')
        .attr('id', 'glow')
        .attr('x', '-50%')
        .attr('y', '-50%')
        .attr('width', '200%')
        .attr('height', '200%');
      glow.append('feGaussianBlur')
        .attr('stdDeviation', '3')
        .attr('result', 'coloredBlur');
      const feMerge = glow.append('feMerge');
      feMerge.append('feMergeNode').attr('in', 'coloredBlur');
      feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

      const g = svg.append('g')
        .attr('transform', `translate(${width/2}, ${height/2}) scale(${zoomLevel})`);

      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(80))
        .force('charge', d3.forceManyBody().strength(-150))
        .force('center', d3.forceCenter(0, 0))
        .force('collision', d3.forceCollide().radius(30));

      const link = g.selectAll('.dep-link')
        .data(links)
        .enter()
        .append('line')
        .attr('class', 'dep-link')
        .attr('stroke', d => d.type === 'import' ? '#4da8da' : '#e9c46a')
        .attr('stroke-width', 1)
        .attr('stroke-opacity', 0.6)
        .attr('marker-end', 'url(#arrowhead)');

      const node = g.selectAll('.node')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(d3.drag()
          .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
          .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
          .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }));

      node.append('circle')
        .attr('r', 6)
        .attr('fill', d => getNodeColor(d))
        .on('mouseover', (e, d) => showTooltipDeps(e, d))
        .on('mouseout', hideTooltip)
        .on('dblclick', (e, d) => {
          e.stopPropagation();
          showHierarchicalDepView(d, nodes, filteredNodeMap, container, width, height, zoomLevel);
        });

      node.append('text')
        .attr('dx', 10)
        .attr('dy', 4)
        .text(d => d.name.replace('.js', ''));

      simulation.on('tick', () => {
        link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
        node.attr('transform', d => `translate(${d.x}, ${d.y})`);
      });

      // Click on background to reset highlight
      svg.on('click', (e) => {
        if (e.target.tagName === 'svg') {
          resetHighlight(node, link);
        }
      });

      svg.call(d3.zoom().scaleExtent([0.1, 4]).on('zoom', (e) => g.attr('transform', e.transform)));
    }

    let highlightedNode = null;

    function showHierarchicalDepView(centerNode, allNodes, nodeMap, container, width, height, zoomLevel) {
      container.innerHTML = '';

      const MAX_DEPTH = 5;
      const MAX_PER_LEVEL = 12;

      // Left side: only direct importedBy (who calls me) - no recursion, only visible nodes
      const leftLevels = [];
      const directImportedBy = centerNode.importedBy
        .filter(id => nodeMap[id])
        .map(id => nodeMap[id])
        .sort((a, b) => b.importedBy.length - a.importedBy.length)
        .slice(0, MAX_PER_LEVEL);
      if (directImportedBy.length > 0) {
        leftLevels.push(directImportedBy);
      }

      // Right side: full recursive imports chain (what I call)
      const rightLevels = [];

      function collectImports(nodeIds, depth, visited) {
        if (depth >= MAX_DEPTH || nodeIds.length === 0) return;
        const level = [];
        const nextIds = [];
        for (const id of nodeIds) {
          const n = nodeMap[id];
          if (!n || visited.has(id)) continue;
          visited.add(id);
          level.push(n);
          n.imports.forEach(imp => { if (!visited.has(imp)) nextIds.push(imp); });
        }
        if (level.length > 0) {
          rightLevels.push(level.sort((a,b) => b.importedBy.length - a.importedBy.length).slice(0, MAX_PER_LEVEL));
          collectImports(nextIds, depth + 1, visited);
        }
      }

      const visitedRight = new Set([centerNode.id]);
      collectImports(centerNode.imports.filter(id => nodeMap[id]), 0, visitedRight);

      // Calculate layout dimensions
      const totalLevels = leftLevels.length + 1 + rightLevels.length;
      const colSpacing = 200;
      const rowSpacing = 40;
      const svgWidth = Math.max(width, totalLevels * colSpacing + 200);
      const maxRows = Math.max(
        ...leftLevels.map(l => l.length),
        ...rightLevels.map(l => l.length),
        1
      );
      const svgHeight = Math.max(height, maxRows * rowSpacing + 150);

      const svg = d3.select(container)
        .append('svg')
        .attr('width', svgWidth)
        .attr('height', svgHeight);

      const defs = svg.append('defs');

      // Glow filter
      const glow = defs.append('filter')
        .attr('id', 'glow')
        .attr('x', '-50%').attr('y', '-50%')
        .attr('width', '200%').attr('height', '200%');
      glow.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'coloredBlur');
      const feMerge = glow.append('feMerge');
      feMerge.append('feMergeNode').attr('in', 'coloredBlur');
      feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

      // Arrow markers
      defs.append('marker').attr('id', 'arrow-red')
        .attr('viewBox', '0 -5 10 10').attr('refX', 12).attr('refY', 0)
        .attr('markerWidth', 5).attr('markerHeight', 5).attr('orient', 'auto')
        .append('path').attr('d', 'M0,-4L10,0L0,4').attr('fill', '#ff6b6b');
      defs.append('marker').attr('id', 'arrow-green')
        .attr('viewBox', '0 -5 10 10').attr('refX', 12).attr('refY', 0)
        .attr('markerWidth', 5).attr('markerHeight', 5).attr('orient', 'auto')
        .append('path').attr('d', 'M0,-4L10,0L0,4').attr('fill', '#4ecdc4');

      const g = svg.append('g');

      // Position all nodes
      const positions = new Map();
      const centerX = leftLevels.length * colSpacing + 100;
      const centerY = svgHeight / 2;

      positions.set(centerNode.id, { x: centerX, y: centerY, node: centerNode, level: 0, type: 'center' });

      // Left levels (importedBy) - reverse order so closest is nearest to center
      leftLevels.forEach((level, li) => {
        const x = centerX - (li + 1) * colSpacing;
        const startY = centerY - ((level.length - 1) * rowSpacing) / 2;
        level.forEach((n, ni) => {
          positions.set(n.id, { x, y: startY + ni * rowSpacing, node: n, level: -(li + 1), type: 'importedBy' });
        });
      });

      // Right levels (imports)
      rightLevels.forEach((level, li) => {
        const x = centerX + (li + 1) * colSpacing;
        const startY = centerY - ((level.length - 1) * rowSpacing) / 2;
        level.forEach((n, ni) => {
          positions.set(n.id, { x, y: startY + ni * rowSpacing, node: n, level: li + 1, type: 'imports' });
        });
      });

      // Draw links between adjacent levels
      // ImportedBy links (left side) - arrows point right (toward center)
      for (let li = 0; li < leftLevels.length; li++) {
        const currentLevel = leftLevels[li];
        const nextLevel = li === 0 ? [centerNode] : leftLevels[li - 1];

        for (const n of currentLevel) {
          const from = positions.get(n.id);
          if (!from) continue;

          // Find which nodes in next level this one depends on
          for (const targetNode of nextLevel) {
            if (n.imports.includes(targetNode.id)) {
              const to = positions.get(targetNode.id);
              if (to) {
                g.append('path')
                  .attr('d', `M${from.x},${from.y} C${from.x + 60},${from.y} ${to.x - 60},${to.y} ${to.x},${to.y}`)
                  .attr('fill', 'none')
                  .attr('stroke', '#ff6b6b')
                  .attr('stroke-width', 1.5)
                  .attr('stroke-opacity', 0.7)
                  .attr('marker-end', 'url(#arrow-red)');
              }
            }
          }
        }
      }

      // Imports links (right side) - arrows point right (away from center)
      for (let li = 0; li < rightLevels.length; li++) {
        const currentLevel = rightLevels[li];
        const prevLevel = li === 0 ? [centerNode] : rightLevels[li - 1];

        for (const prevNode of prevLevel) {
          const from = positions.get(prevNode.id);
          if (!from) continue;

          for (const n of currentLevel) {
            if (prevNode.imports.includes(n.id)) {
              const to = positions.get(n.id);
              if (to) {
                g.append('path')
                  .attr('d', `M${from.x},${from.y} C${from.x + 60},${from.y} ${to.x - 60},${to.y} ${to.x},${to.y}`)
                  .attr('fill', 'none')
                  .attr('stroke', '#4ecdc4')
                  .attr('stroke-width', 1.5)
                  .attr('stroke-opacity', 0.7)
                  .attr('marker-end', 'url(#arrow-green)');
              }
            }
          }
        }
      }

      // Draw nodes
      for (const [id, pos] of positions) {
        const nodeG = g.append('g')
          .attr('transform', `translate(${pos.x}, ${pos.y})`)
          .attr('cursor', 'pointer')
          .on('dblclick', (e) => {
            e.stopPropagation();
            showHierarchicalDepView(pos.node, allNodes, nodeMap, container, width, height, zoomLevel);
          });

        const isCenter = pos.type === 'center';
        const radius = isCenter ? 12 : 6;
        const color = isCenter ? '#fff' : getNodeColor(pos.node);

        nodeG.append('circle')
          .attr('r', radius)
          .attr('fill', color)
          .attr('stroke', isCenter ? '#4da8da' : '#fff')
          .attr('stroke-width', isCenter ? 3 : 1)
          .attr('filter', isCenter ? 'url(#glow)' : 'none')
          .on('mouseover', (e) => showTooltipDeps(e, pos.node))
          .on('mouseout', hideTooltip);

        const labelX = pos.type === 'importedBy' ? -10 : 10;
        const anchor = pos.type === 'importedBy' ? 'end' : 'start';
        nodeG.append('text')
          .attr('x', labelX)
          .attr('y', 4)
          .attr('text-anchor', anchor)
          .attr('fill', isCenter ? '#fff' : '#aaa')
          .attr('font-size', isCenter ? '11px' : '9px')
          .attr('font-weight', isCenter ? 'bold' : 'normal')
          .text(pos.node.name.replace('.js', ''));
      }

      // Level labels
      const levelLabels = g.append('g');
      for (let i = leftLevels.length; i >= 1; i--) {
        const x = centerX - i * colSpacing;
        levelLabels.append('text').attr('x', x).attr('y', 25)
          .attr('text-anchor', 'middle').attr('fill', '#666').attr('font-size', '10px')
          .text(`-${i}`);
      }
      levelLabels.append('text').attr('x', centerX).attr('y', 25)
        .attr('text-anchor', 'middle').attr('fill', '#4da8da').attr('font-size', '11px').attr('font-weight', 'bold')
        .text('0');
      for (let i = 1; i <= rightLevels.length; i++) {
        const x = centerX + i * colSpacing;
        levelLabels.append('text').attr('x', x).attr('y', 25)
          .attr('text-anchor', 'middle').attr('fill', '#666').attr('font-size', '10px')
          .text(`+${i}`);
      }

      // Legend
      const legend = g.append('g').attr('transform', `translate(20, 50)`);
      legend.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 25).attr('y2', 0)
        .attr('stroke', '#ff6b6b').attr('stroke-width', 2);
      legend.append('text').attr('x', 30).attr('y', 4).attr('fill', '#ccc').attr('font-size', '10px')
        .text(`â† è°ƒç”¨è€… (${directImportedBy.length})`);
      legend.append('line').attr('x1', 0).attr('y1', 18).attr('x2', 25).attr('y2', 18)
        .attr('stroke', '#4ecdc4').attr('stroke-width', 2);
      legend.append('text').attr('x', 30).attr('y', 22).attr('fill', '#ccc').attr('font-size', '10px')
        .text(`è°ƒç”¨é“¾ â†’ (${rightLevels.reduce((s,l) => s+l.length, 0)})`);

      // Back button
      const backBtn = g.append('g')
        .attr('transform', `translate(${svgWidth - 90}, 20)`)
        .attr('cursor', 'pointer')
        .on('click', () => renderGraph());
      backBtn.append('rect').attr('width', 70).attr('height', 24).attr('rx', 4)
        .attr('fill', '#16213e').attr('stroke', '#4da8da');
      backBtn.append('text').attr('x', 35).attr('y', 16)
        .attr('text-anchor', 'middle').attr('fill', '#4da8da').attr('font-size', '11px')
        .text('â† è¿”å›');

      // Title
      g.append('text').attr('x', centerX).attr('y', 25)
        .attr('text-anchor', 'middle').attr('fill', '#fff').attr('font-size', '13px')
        .attr('dy', -15)
        .text(centerNode.name);

      // Zoom and pan
      svg.call(d3.zoom().scaleExtent([0.2, 3]).on('zoom', (e) => g.attr('transform', e.transform)));
    }

    function highlightDepTree(d, allNodes, nodeMap, nodeSelection, linkSelection) {
      // Toggle off if clicking same node
      if (highlightedNode === d.id) {
        resetHighlight(nodeSelection, linkSelection);
        return;
      }
      highlightedNode = d.id;

      // Find all nodes in dependency tree (recursive)
      const relatedIds = new Set();

      function addImports(nodeId, depth = 0) {
        if (depth > 10 || relatedIds.has(nodeId)) return;
        relatedIds.add(nodeId);
        const n = nodeMap[nodeId];
        if (n) {
          n.imports.forEach(imp => addImports(imp, depth + 1));
        }
      }

      function addImportedBy(nodeId, depth = 0) {
        if (depth > 10 || relatedIds.has(nodeId)) return;
        relatedIds.add(nodeId);
        const n = nodeMap[nodeId];
        if (n) {
          n.importedBy.forEach(by => addImportedBy(by, depth + 1));
        }
      }

      addImports(d.id);
      addImportedBy(d.id);

      // Apply visual styles - highlight related, dim others
      nodeSelection.select('circle')
        .attr('opacity', n => relatedIds.has(n.id) ? 1 : 0.1)
        .attr('r', n => n.id === d.id ? 12 : (relatedIds.has(n.id) ? 8 : 3))
        .attr('stroke', n => n.id === d.id ? '#fff' : (relatedIds.has(n.id) ? '#fff' : 'none'))
        .attr('stroke-width', n => n.id === d.id ? 3 : (relatedIds.has(n.id) ? 1.5 : 0))
        .attr('filter', n => relatedIds.has(n.id) ? 'url(#glow)' : 'none');

      nodeSelection.select('text')
        .attr('opacity', n => relatedIds.has(n.id) ? 1 : 0.05)
        .attr('fill', n => n.id === d.id ? '#fff' : (relatedIds.has(n.id) ? '#eee' : '#666'))
        .attr('font-weight', n => n.id === d.id ? 'bold' : 'normal');

      linkSelection
        .attr('stroke', l => {
          const srcId = typeof l.source === 'object' ? l.source.id : l.source;
          const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
          if (!relatedIds.has(srcId) || !relatedIds.has(tgtId)) return '#0f3460';
          // Highlight imports in cyan, importedBy in yellow
          return l.type === 'import' ? '#00ffff' : '#ffff00';
        })
        .attr('stroke-opacity', l => {
          const srcId = typeof l.source === 'object' ? l.source.id : l.source;
          const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
          return relatedIds.has(srcId) && relatedIds.has(tgtId) ? 1 : 0.03;
        })
        .attr('stroke-width', l => {
          const srcId = typeof l.source === 'object' ? l.source.id : l.source;
          const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
          return relatedIds.has(srcId) && relatedIds.has(tgtId) ? 2.5 : 0.3;
        });
    }

    function resetHighlight(nodeSelection, linkSelection) {
      highlightedNode = null;
      nodeSelection.select('circle')
        .attr('opacity', 1)
        .attr('r', 6)
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
        .attr('filter', 'none');
      nodeSelection.select('text')
        .attr('opacity', 1)
        .attr('fill', '#ccc')
        .attr('font-weight', 'normal');
      linkSelection
        .attr('stroke', d => d.type === 'import' ? '#4da8da' : '#e9c46a')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', 1);
    }

    function showTooltipDeps(event, d) {
      const tooltip = document.getElementById('tooltip');
      const status = getFileStatus(d.id);
      const statusClass = status === 'covered' ? 'status-covered' : status === 'stale' ? 'status-stale' : 'status-untested';

      let html = `<div class="title">${d.id}</div>`;
      html += `<div class="row"><span class="label">çŠ¶æ€:</span><span class="status ${statusClass}">${status}</span></div>`;
      html += `<div class="row"><span class="label">ä¾èµ–:</span><span class="value">${d.imports.length} ä¸ªæ–‡ä»¶</span></div>`;
      html += `<div class="row"><span class="label">è¢«ä¾èµ–:</span><span class="value">${d.importedBy.length} ä¸ªæ–‡ä»¶</span></div>`;
      if (d.imports.length > 0) {
        html += `<div class="row"><span class="label">â†’</span><span class="value">${d.imports.slice(0,3).map(i => i.split('/').pop()).join(', ')}${d.imports.length > 3 ? '...' : ''}</span></div>`;
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (event.pageX + 10) + 'px';
      tooltip.style.top = (event.pageY + 10) + 'px';
      tooltip.style.opacity = 1;
    }

    function showTooltip(event, d) {
      const tooltip = document.getElementById('tooltip');
      const data = d.data;
      const status = getFileStatus(data.id);
      const statusClass = status === 'covered' ? 'status-covered' : status === 'stale' ? 'status-stale' : 'status-untested';

      let html = `<div class="title">${data.id}</div>`;
      if (!data.isModule) {
        html += `<div class="row"><span class="label">çŠ¶æ€:</span><span class="status ${statusClass}">${status}</span></div>`;
        if (data.imports?.length) html += `<div class="row"><span class="label">ä¾èµ–:</span><span class="value">${data.imports.length} ä¸ªæ–‡ä»¶</span></div>`;
        if (data.importedBy?.length) html += `<div class="row"><span class="label">è¢«ä¾èµ–:</span><span class="value">${data.importedBy.length} ä¸ªæ–‡ä»¶</span></div>`;
        if (data.exports?.length) html += `<div class="row"><span class="label">å¯¼å‡º:</span><span class="value">${data.exports.slice(0,3).join(', ')}${data.exports.length > 3 ? '...' : ''}</span></div>`;
      } else if (data.files) {
        html += `<div class="row"><span class="label">æ–‡ä»¶æ•°:</span><span class="value">${data.files.length}</span></div>`;
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (event.pageX + 10) + 'px';
      tooltip.style.top = (event.pageY + 10) + 'px';
      tooltip.style.opacity = 1;
    }

    function hideTooltip() {
      document.getElementById('tooltip').style.opacity = 0;
    }

    // Event listeners
    document.getElementById('viewMode').addEventListener('change', renderGraph);
    document.getElementById('moduleLevel').addEventListener('change', renderGraph);
    document.getElementById('zoom').addEventListener('input', renderGraph);
    document.getElementById('showImports').addEventListener('change', renderGraph);
    document.getElementById('showImportedBy').addEventListener('change', renderGraph);
    document.getElementById('depsFilter').addEventListener('change', renderGraph);
    document.getElementById('searchFile').addEventListener('input', debounce(renderGraph, 300));

    function debounce(fn, delay) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Load data on page load
    loadData();
  </script>
</body>
</html>
